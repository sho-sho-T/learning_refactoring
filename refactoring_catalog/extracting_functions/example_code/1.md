# 例１

## 1. 初期コード

リファクタリング前のコードから始めます。

```typescript
interface Order {
  customer: string;
  items: { name: string; price: number }[];
}

const printOrder = (order: Order): void => {
  let total = 0;
  console.log("注文詳細:");
  console.log(`顧客名: ${order.customer}`);

  console.log("注文アイテム:");
  for (const item of order.items) {
    console.log(`- ${item.name}: ¥${item.price}`);
    total += item.price;
  }

  console.log(`合計金額: ¥${total}`);
};
```

## 2. 抽出する部分の特定

注文アイテムの出力と合計金額の計算、および顧客情報の出力を別の関数として抽出します。

## 3. 新しい関数の作成と配置

関数の意図に沿って命名し、`printOrder`関数の下に定義します。

```typescript
interface Order {
  customer: string;
  items: { name: string; price: number }[];
}

const printOrder = (order: Order): void => {
  console.log("注文詳細:");
  printCustomerInfo(order.customer);
  const total = printOrderItems(order.items);
  printTotalAmount(total);
};

const printCustomerInfo = (customer: string): void => {
  console.log(`顧客名: ${customer}`);
};

const printOrderItems = (items: { name: string; price: number }[]): number => {
  let itemTotal = 0;
  console.log("注文アイテム:");
  for (const item of items) {
    console.log(`- ${item.name}: ¥${item.price}`);
    itemTotal += item.price;
  }
  return itemTotal;
};

const printTotalAmount = (amount: number): void => {
  console.log(`合計金額: ¥${amount}`);
};
```

## 4. スコープの確認と調整

関数をトップレベルで定義しているため、`order`オブジェクトへのアクセスが必要な部分を引数として渡すように調整しています。

## 5. コンパイルとテスト

コードをコンパイルし、動作をテストして問題がないことを確認します。

## 6. さらなる改善の検討

現在の構造で、各関数の責任が明確になっているか確認します。必要に応じて、さらに関数を分割したり、共通の処理を抽出したりすることを検討します。

## 7. 最終確認

最終的なコードが読みやすく、各関数が単一の責任を持つようになったことを確認します。必要に応じて関数名や変数名を調整し、コードの意図がより明確になるようにします。

この最終的なコード構造では、メイン関数である`printOrder`が最初に配置され、その下にヘルパー関数が続いています。これにより、コードの全体的な流れが理解しやすくなっています。
