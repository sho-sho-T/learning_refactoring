# レコードのカプセル化

## 例

```typeScript

organization = {name: "Acme Gooseberries", country: "GB"}

```

**⇩**

```typeScript

class Organization {
    constructor(data) {
        this._name = data.name;
        this._country = data.country;
    }

    get name() {
        return this._name;
    }

    set name(arg) {
        this._name = arg;
    }

    get country() {
        return this._country;
    }

    set country(arg) {
        this._country = arg;
    }
}

```

## 動機

レコード構造：関連するデータを一緒にグループ化する直感的な方法を提供し、緩いデータの群れの代わりに意味のあるデータ単位を渡すことを可能とする。

↑ 　欠点あり

レコードに格納されている値と計算した明確な区別を強要される

変更可能なデータについてはレコード化するより、オブジェクト化したほうが良い。

オブジェクトであれば、保持されているものを隠蔽し、三つの値全てに対するメソッドを用意できる

## 手順

### ① レコードを保持する変数に「変数のカプセル化」を施す

- コード名をカプセル化するための関数には、検索しやすい名前を付ける。

### ② 変数の中身を、レコードをラップする簡単なクラスに置き換える。レコードをそのまま返すアクセサをそのクラスに定義、変数をカプセル化する関数を変更して、アクセサを使うようにする

### ③ テストする

### ④ レコードそのものではなく、オブジェクトを返す関数を用意

### ⑤ レコードの使用箇所ごとに、レコードを返す関数の呼び出しを、オブジェクトを返す関数の呼び出しに置き換える。フィールドデータの取得にはオブジェクトのアクセサを使うようにする。必要ならばそのためをアクセサを作る。変更のたびにテストする。

### ⑥ 生データへのアクセサと、検索しやすくしておいたレコードそのまま返す関数をクラスから取り除く

### ⑦ テストする

### ⑧ レコードのフィールド自体が構造的である場合「レコードのカプセル化」と「コレクションのカプセル化」を再帰的に施すことを検討する。
