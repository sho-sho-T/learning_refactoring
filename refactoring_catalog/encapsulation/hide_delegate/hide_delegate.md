# 委譲の隠蔽：詳細ガイド

## 概要

「委譲の隠蔽」は、オブジェクト間の依存関係を減らし、カプセル化を強化するリファクタリング技術です。クライアントが直接アクセスしていた委譲オブジェクトへのアクセスを、サーバオブジェクトを通じて行うように変更します。

## 例

### Before

```typescript
let manager = aPerson.department.manager;
```

### After

```typescript
let manager = aPerson.manager;

class Person {
  get manager() {
    return this.department.manager;
  }
}
```

## 動機

1. **カプセル化の強化**: システムの各部分が他の部分について知るべき情報を最小限に抑えます。
2. **依存関係の削減**: クライアントコードが直接知る必要のあるオブジェクトの数を減らします。
3. **変更の影響範囲の制限**: 内部構造の変更がクライアントコードに与える影響を最小限に抑えます。
4. **インターフェースの簡素化**: クライアントから見たオブジェクトのインターフェースをシンプルにします。
5. **テストの容易性**: モックオブジェクトの作成が容易になり、ユニットテストが書きやすくなります。

## 手順

1. **委譲メソッドの作成**:

   - サーバオブジェクト（この例では `Person` クラス）に、委譲先オブジェクト（`department`）の各メソッドに対応する単純な委譲メソッドを作成します。

   ```typescript
   class Person {
     private department: Department;

     get manager() {
       return this.department.manager;
     }
   }
   ```

2. **クライアントコードの修正**:

   - クライアントコードを修正し、直接委譲先オブジェクトにアクセスする代わりに、サーバオブジェクトの新しい委譲メソッドを呼び出すようにします。
   - 変更のたびにテストを実行し、機能が正しく動作することを確認します。

   ```typescript
   // Before
   let manager = aPerson.department.manager;

   // After
   let manager = aPerson.manager;
   ```

3. **不要なアクセサの削除**:

   - クライアントコードで委譲先オブジェクト（`department`）への直接アクセスが不要になった場合、サーバオブジェクト（`Person`）から委譲先オブジェクトへのアクセサを削除します。

   ```typescript
   class Person {
     private department: Department;

     // departmentのpublicなgetterを削除

     get manager() {
       return this.department.manager;
     }
   }
   ```

4. **テスト**:
   - すべての変更が完了した後、総合的なテストを実行し、システム全体が正しく動作することを確認します。

## 利点

- **カプセル化の向上**: クライアントは内部構造の詳細を知る必要がなくなります。
- **変更の容易性**: 内部実装の変更がクライアントに影響を与えにくくなります。
- **依存関係の管理**: オブジェクト間の依存関係が明確になり、管理しやすくなります。
- **テスタビリティの向上**: モックオブジェクトの作成が容易になり、ユニットテストが書きやすくなります。

## 注意点

- **過剰な委譲**: 必要以上に委譲を隠蔽すると、かえってコードが複雑になる可能性があります。適切なバランスを保つことが重要です。
- **パフォーマンス**: 多数の委譲メソッドを追加すると、わずかながらパフォーマンスに影響を与える可能性があります。
- **インターフェースの設計**: 委譲を隠蔽する際は、クライアントにとって意味のある抽象化レベルを提供することが重要です。

## まとめ

「委譲の隠蔽」は、オブジェクト指向設計の重要な原則であるカプセル化を強化するための有効な技術です。この技術を適切に使用することで、コードの保守性と拡張性が向上し、長期的にはより堅牢なシステムを構築することができます。ただし、過剰な適用は避け、システムの要件とデザインに基づいて適切に判断することが重要です。
