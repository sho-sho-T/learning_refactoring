# 仲介人の除去：詳細ガイド

## 概要

「仲介人の除去」は、過剰な委譲を解消し、直接的なオブジェクト間の通信を復活させるリファクタリング技術です。これは「委譲の隠蔽」の逆の操作であり、適切なバランスを取るために使用されます。

## 例

### Before

```typescript
let manager = aPerson.manager;

class Person {
  private department: Department;

  get manager() {
    return this.department.manager;
  }
}
```

### After

```typescript
let manager = aPerson.department.manager;

class Person {
  department: Department;
}
```

## 動機

1. **過剰な委譲の解消**: 「委譲の隠蔽」を適用しすぎると、単純な委譲メソッドが多数発生し、コードが冗長になる場合があります。

2. **直接的なアクセスの必要性**: クライアントが委譲先オブジェクトの多くの機能を直接使用する必要がある場合、仲介のオーバーヘッドが不要になります。

3. **柔軟性の向上**: 直接アクセスにより、クライアントが委譲先オブジェクトの新しい機能を容易に利用できるようになります。

4. **パフォーマンスの最適化**: 不必要な中間層を除去することで、わずかながらパフォーマンスが向上する可能性があります。

5. **コードの簡素化**: 単純な転送メソッドを削除することで、クラスの責務がより明確になります。

## 手順

1. **委譲先オブジェクトの getter の作成**:

   - 委譲先のオブジェクトを直接取得する getter メソッドを作成します。

   ```typescript
   class Person {
     private _department: Department;

     get department(): Department {
       return this._department;
     }
   }
   ```

2. **クライアントコードの修正**:

   - 委譲メソッドを使用しているクライアントコードを、新しい getter を使用したメソッドチェーンに置き換えます。
   - 変更のたびにテストを実行し、機能が正しく動作することを確認します。

   ```typescript
   // Before
   let manager = aPerson.manager;

   // After
   let manager = aPerson.department.manager;
   ```

3. **不要な委譲メソッドの削除**:

   - すべてのクライアントコードを更新した後、不要になった委譲メソッドを削除します。

   ```typescript
   class Person {
     department: Department;

     // managerのgetterを削除
   }
   ```

4. **最終テスト**:
   - すべての変更が完了した後、総合的なテストを実行し、システム全体が正しく動作することを確認します。

## 利点

- **コードの簡素化**: 不要な中間層を除去することで、コードがより直接的で理解しやすくなります。
- **柔軟性の向上**: クライアントが委譲先オブジェクトの新機能を容易に利用できるようになります。
- **パフォーマンスの最適化**: 不要なメソッド呼び出しが減少し、わずかながらパフォーマンスが向上する可能性があります。

## 注意点

- **カプセル化の弱体化**: 直接アクセスを許可することで、オブジェクト間の結合度が高くなる可能性があります。
- **変更の影響**: 内部実装の変更が、より多くのクライアントコードに影響を与える可能性があります。
- **バランスの重要性**: 「委譲の隠蔽」と「仲介人の除去」のバランスを適切に取ることが重要です。

## まとめ

「仲介人の除去」は、過剰なカプセル化を解消し、適切なレベルの抽象化を実現するための重要な技術です。しかし、その適用には慎重な判断が必要です。システムの要件、設計方針、そして将来の拡張性を考慮しながら、「委譲の隠蔽」と「仲介人の除去」を適切に使い分けることが、良好なオブジェクト指向設計の鍵となります。リファクタリングは継続的なプロセスであり、システムの進化に合わせてこれらの技術を適用し続けることが重要です。
