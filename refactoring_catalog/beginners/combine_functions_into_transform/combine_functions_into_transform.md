# 関数群の変換への集約

## 例

```typeScript

const base = (aReading) => {
    ...
};

const taxableCharge = (aReading) => {
    ...
};

```

**⇩**

```typeScript

const enrichReading = (argReading) => {
    // 入力オブジェクトのディープコピーを作成
    // これにより、元のオブジェクトが変更されることを防ぐ
    const aReading = _.cloneDeep(argReading);

    // baseCharge を計算し、新しいプロパティとして追加
    aReading.baseCharge = base(aReading);

    // taxableCharge を計算し、新しいプロパティとして追加
    aReading.taxableCharge = taxableCharge(aReading);

    // 拡張されたオブジェクトを返す
    return aReading;
};


```

## 動機

ソフトウェアの多くは、プログラムにデータを投入して、そこからさまざまな派生情報を計算する処理を含む。
そうした派生値はさまざまな箇所で必要になり、その計算は派生値が参照されるたびに繰り返される。

⇩

こうした派生値はまとめた方が望ましく、一貫した探しやすい場所で更新が行われるようにして、重複したロジックを避けたい。

特に複雑なドメインモデルや、同じデータに対して複数の計算を行う必要がある場合に非常に有効

## 手順

### ① 変換されるレコードを入力とし、同じ値を返す変換関数を作る。

- 通常はレコードのディープコピーが行われる

### ② ロジックを選んでその本体を変換関数側に移し、レコードに新たなフィールドを設ける。そのフィールドを使うようにクライアント側のコードを変更する。

### ③ テストする

### ④ その他の関連した関数群について上記の手順を繰り返す。
